function S = importpolygonsfile(filename)
% S = IMPORTPOLYGONSFILE(FILENAME)
% Reads a plain-text file as generated by the Pre-Processor tool, containing the (geometrical)
% definition of either a mount-model or a module-model. Including its outline- and subdivision
% polyogns (modules or cells, respectively), mechanical specifications, and default connection
% scheme; following the format:
%
%     #property_1: value_1
%     #property_2: value_2
%     #...
%     #(comments)
%     #...
%     #outline_polygon: x1;y1;x2;y2;x3;y3; ... ;xn;yn
%     #divisions(n;string_id;x1;y1;x2;y2;...)
%     1;1;x1;y1;x2;y2;x3;y3; ... ;xm;ym
%     2;1;x1;y1;x2;y2;x3;y3; ... ;xm;ym
%     ...
%
% Propperty-value pairs required for MODULE-MODEL definitions are:
%
%     #file_format: PREPROCESSOR_VX.X,  string used for version control. 
%     #module_id: string ID for module-model (should match filename without extension)
%     #outline_polygon: 2N - vector vertex coordinates for outline-polygon
%
% Propperty-value pairs required for MOUNT-MODEL definitions are:
%
%     #file_format: PREPROCESSOR_VX.X,  string used for version control. 
%     #mount_model_id: string ID for mount-model (should match filename without extension)
%     #module_id: (string)  ID of module-geometry file (without extension).
%     #mount_type: (string) mount-type key {2a, 1aV, 1aF, 1aC, 0a}
%     #outline_polygon: 2N - vector vertex coordinates for outline-polygon
%     #axis_offset: (Optional, 3-vector) distance, in mount-coordinates, from center of rotation
%                   (nominal mount position) to mount-coordinate-origin (on PV surface)
%     #center_height: (Optional, scalar) distance from nominal mount position to ground.
%     #tilt: (Optional, scalar) used to estimate center_height when not available.
%     #analysed_pts: (optional, 2N-vector) coordinates of N node-points for diffuse-shading 
%                   analysis
%     #track_limits: (Optional, 2/4-vector) decimal-degree-angles.
%     #backtracking: (string) for 1aC and 1aF types, {on, off,  smart}
%
% Data columns following the #divisions... header represent mount/module subdivisions and their
% default connection scheme:
%
%     n: (integer) module-position index in mount
%     string_id: (integer) indexes that associate each module to a predefined-string
%     x1;y1;x2;y2;...: 2N - vector vertex coordinates for module/cell-polygon
%
% FILENAME: file name or look-up pattern, passed through PICKFILE()
%
% S: Results structure, with fields {name,geom,info} and, for mount-models, optional fields
%   {module,pidx,centerheight,axisoffset,tracklimits,backtracking}:
%   S.name: mount_model_id (for mounts) or module_id (for modules)
%   S.geom: pvArea object, with two/three levels depth, containing the outline and division
%       polygons in S.geom.border and S.elements(j)[.elements(k)].border, respectively.
%   S.info: cell-array of included comments that do not match recognized Property-value pairs

    TOL = 0.01; % percent on area, to check that all elements are equal
    
    FLD.mod.req = {'file_format','module_id','outline_polygon'};
    FLD.trck.req = {'file_format','mount_model_id','module_id','mount_type','outline_polygon'};
    FLD.trck.opt = {'axis_offset','center_height','track_limits','backtracking','tilt','analysed_pts'};
    
    % Find property-value pairs in #header rows
    allfields = unique([FLD.trck.req,FLD.trck.opt,FLD.mod.req],'stable');
    
    if nargin < 1 || isempty(filename), filename = '*'; end
   
    filename = pickfile(filename,'Pick a mount-/module-model definition file');
    data = readtxtfile(filename,allfields,'delim',';','ignorecase',true);
    assert(~isempty(data),'Unrecognized file format');
    data.comments = data.comments(1:end-1); % dump last header line #divisions(n;...)

    specs = data.params;
    info = data.comments;
    
    % Check for required fields, detect if mount or module
    xt = filename(end-4:end);
    istrck = strcmpi(xt,'tpoly') || any(arrayfun(@(x) contains(x.name,'phystrck'),dbstack()));
    ismodule = strcmpi(xt,'mpoly') || any(arrayfun(@(x) contains(x.name,'physmod'),dbstack()));
    if istrck && ~ismodule
        missing = setdiff(FLD.trck.req,fieldnames(specs));
        msg = shortliststr(missing,'missing header #key:value pair','empty','');
    elseif ismodule && ~istrck
        missing = setdiff(FLD.mod.req,fieldnames(specs));
        msg = shortliststr(missing,'missing header #key:value pair','empty','');
    else
        istrck = all(isfield(specs,FLD.trck.req));
        ismodule = all(isfield(specs,FLD.mod.req));
        if ~xor(istrck,ismodule), msg = 'Unrecognized file format/extension'; else, msg = ''; end
    end
    assert(isempty(msg),msg);
    
    if istrck
        validtypes = {'2a','1aV','1aF','1aC','0a'};
        trcktype = find(strcmpi(specs.mount_type,validtypes),1);
        assert(~isempty(trcktype),'Invalid mount-type, expecting {2a,1aV,1aF,1aC, or 0a}');
        specs.mount_type = validtypes{trcktype}; % fix any caps inconsistency
    end
    
    % Assign required fields
    if istrck
        S.name = specs.mount_model_id;
        S.type = specs.mount_type;
        S.module = specs.module_id; 
    else
        S.name = specs.module_id;
    end
    outline = readpolygon(specs.outline_polygon);
	% initialize a pvArea object with outline polygon and the required number of elements
	S.geom = pvArea(outline.x,outline.y);
    
    S.pidx = data.data{1};
    groupidx = data.data{2};
    Ne = numel(S.pidx);
    
    % fix zero-based indexing
    if any(S.pidx == 0)
        S.pidx = S.pidx + 1; 
        warning2info('pidx0','Fixing zero-based position-indexes');
    end 
    if any(groupidx == 0)
        groupidx = groupidx + 1; 
        warning2info('groupidx0','Fixing zero-based group-indexes');
    end 
    
    % Arrange vertices so that pts(:,:,j) returns an N·2 table of vertices for element j
    pts = cat(2,data.data{3:end});
    pts = permute(cat(3,pts(:,1:2:end),pts(:,2:2:end)),[2 3 1]); 
    
    % Analyze Division indices, check for sort order and possible gaps
    assert(numel(unique(S.pidx))==Ne,'importpolygonsfile:upidx','Division indices are not unique');
    
    [S.pidx,I] = sort(S.pidx); % make sure elements are sorted by pidx (*)
    if ~isequal(I',1:Ne), pts = pts(:,:,I); end
    
    if any(S.pidx' ~= 1:Ne)
       warning2info('pidx','Position-indices don''t match 1:N, mount might have gaps');
    end
    
    % Create element-polygons
    S.geom.elements = arrayfun(@(j) pvArea(pts(:,1,j),pts(:,2,j)),1:Ne);
    
    % check that all elements are equal within provided tolerance
    TOL = max(TOL, eps(max(pts(:))^2));
    elementareas = [S.geom.elements.area];
    assert(all(abs(elementareas - mode(elementareas)) < TOL),'Not all elements seem equal');
    
    % Check that provided outline fully contains sub-elements
    if ~isvoid(substractpolygons([S.geom.elements.border],S.geom.border))
        warning2info('envelope','Elements surpass outline-polygon, using merged area');
        S.geom.border = mergepolygon(S.geom.border,areaenvelope(S.geom));
    end
    
    % Let S.geom ALWAYS be centered
    c = centroid(S.geom.border);
    [w,h] = rectangleproperties(S.geom.border);
    if istrck
        switch S.type
            case '0a', c(:) = 0;           % no axis, so it shouldn't matter
            case {'1aC','1aF'}, c(1) = 0;  % let the point rest anywhere on x'
            otherwise                      % do nothing, i.e. full re-center      
        end
        if any(c./[w,h] > 0.01)
        % [partially] re-center tracker, with warning
        
            S.geom = translate(S.geom,-c);

            dependent = {'axis_offset', 'center_height', 'analysed_pts'};
            dependent(~cellfun(@(x) isfield(specs,x),dependent)) = [];
            if ~isempty(dependent)
                dependent = regexprep(dependent,'(.*)','#$1');
                msg = sprintf(' Verify %s on %s.', shortliststr(dependent),filename);
            else, msg = ''; 
            end

            warning(['Tracker geometry is off-center, applying (%+0.1f cm, %+0.1f cm) ',...
                     'correction on (x'',y'').%s'],-100*c(1),-100*c(2),msg);
        end
    else
        S.geom = translate(S.geom,-c); % re-center modules quietly
    end

    % Arrange into 3-levels-deep structure for modules with bypass-diodes
    if ismodule && max(groupidx) > 1
        e = arrayfun(@(j) pvArea(S.geom.elements(groupidx == j)),1:max(groupidx));
        S.geom = pvArea(S.geom.border,e);
    end

    if istrck
    % Parse optional mount specifications...
        str2vector = @(s) str2double(strsplit(s,';'));
        listvector = @(c) strjoin(cellstr(num2str(c(:))),';');
        
        % Axis-offset
        if isfield(specs,'axis_offset')
            S.axisoffset = str2vector(specs.axis_offset);
            if isscalar(S.axisoffset), S.axisoffset = [0,0,S.axisoffset]; end
            if numel(S.axisoffset) ~= 3 || any(isnan(S.axisoffset)), S.axisoffset = []; end
        else
            S.axisoffset = []; 
        end
        if isempty(S.axisoffset)
            warning2info('axisoffset','Invalid or missing axis-offset, set to zero!');
            S.axisoffset = [0,0,0];
        end
        
        % Track-limits
        if ~strcmp(S.type,'0a')
            if isfield(specs,'track_limits')
                S.tracklimits = str2vector(specs.track_limits);
                if any(isnan(S.tracklimits)), S.tracklimits = []; end
            else
                S.trackimits = [];
            end
            if any(strcmp(S.type,{'1aF','1aC','1aV'})) && isscalar(S.tracklimits)
                warning2info('scalarlims','tracklimits set to ±%0.1f',abs(S.tracklimits));
                S.tracklimits = [-1,1]*abs(S.tracklimits); 
            end
            switch S.type    
                case '2a'
                    limitsok = @(x) numel(x) == 4 && x(2) >= x(1) && x(4) >= x(3);
                    deflimits = [-150 150 0 90];
                case '1aV'
                    limitsok = @(x) numel(x) == 2 && x(2) >= x(1);
                    deflimits = [-150 150];
                case {'1aF','1aC'}
                    limitsok = @(x) numel(x) == 2 && x(2) >= x(1);
                    deflimits = [-45 45];
            end
            if ~limitsok(S.tracklimits)
                S.tracklimits = deflimits;
                warning2info('tracklims','Invalid track-limits, set to [%s]',listvector(deflimits));
            end
        end

        % Backtracking
        if any(strcmp(S.type,{'1aC','1aF'}))
            if isfield(specs,'backtracking')
                switch lower(specs.backtracking)
                    case {'on','1','true'}, S.backtracking = 1;
                    case {'off','0','false'}, S.backtracking = 0;
                    case {'smart','-1'}, S.backtracking = -1;
                    otherwise, S.backtracking = [];
                end
            else
                S.backtracking = [];
            end
            if isempty(S.backtracking)
                warning2info('backtracking','Unknown backtracking algorithm, set to ''off''');
                S.backtracking = 0;
            end
        end
        
        % Center-height
        if isfield(specs,'tilt'), S.tilt = str2double(specs.tilt); end
        if isfield(specs,'center_height'), S.centerheight = str2double(specs.center_height);
        else, S.centerheight = NaN;
        end
        if ~isscalar(S.centerheight) || isnan(S.centerheight)
            S.centerheight = guesscenterheight(S);
            warning2info('centerheight','Invalid or missing center-height, set to %0.2f',S.centerheight);
            
        end
        
        % Diffuse-shading-analysis nodes
        if isfield(specs,'analysed_pts')
            S.analysedpoints = reshape(str2vector(specs.analysed_pts),2,[]);
        else
            pts = getSimOption('analysedpts');  % see QUADRATUREPOINTS
            [W,H,c] = rectangleproperties(S.geom.border);
            [S.analysedpoints,~,pts] = quadraturepoints(pts,-[W,H]/2,[W,H]/2);
            S.analysedpoints = round(S.analysedpoints' + c,2);
            msg = sprintf('%d x %d array of Gauss-Legendre quadrature nodes for %0.1f x %0.1f m rectangle.',pts,W,H);
            warning2info('analysed_pts','Invalid or missing analysed-points, set to %s',msg);
        end
    end
    S.info = info;
    
    function warning2info(id,msg,varargin)
        info{end+1} = msg;
        warning(['importpolygonsfile:' id],msg,varargin{:});
    end
end

function Poly = readpolygon(polystring)
% Read a string of the form px(0);py(0);px(1);py(1); ... ;px(m);py(m); as a polygon with m vertices

    vertices = textscan(polystring,'%f %f','Delimiter',';');
    Poly = polygon(vertices{1},vertices{2});
end

function h = guesscenterheight(Trck)
% Estimate mount-center-height based on clearance from ground at critical position

    gclear = getSimOption('mounts.groundclearance');

    % Get critical sun-elevation angle
    switch Trck.type
        case {'1aF','1aC'}
            el = 90 - Trck.tracklimits(2);  % max tilt
            Trck.backtracking = false;
        case {'1aV','0a'}
            el = 0;                          % doesn't really matter
            assert(isfield(Trck,'tilt'),['Can''t guess center_height without tilt for 0a/1aV mounts. ',...
                                         'Add #center_height: METERS or #tilt: DEGREES to *.mounts file']);
        case '2a', el = max(0,Trck.tracklimits(3));         % at lower elevation limit
    end
    Trck.slope = 0;
    Trck.azimuth = 0;

    % Calculate mean rotation matrixes at critical position (azimuth zero)
    R = mountrotations(Trck,0,el);   % should be a 3·3 matrix (one mount, one position)

    % Tracker at starting position
    p0 = polygon3d(Trck.geom.border);
    p0 = polytranslate(p0,Trck.axisoffset);
    p0 = polyrotate(p0,R);
    h = gclear - min(p0.z);
end
            
