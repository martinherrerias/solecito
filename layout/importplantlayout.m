function S = importplantlayout(filename)
% S = IMPORTPLANTLAYOUT(FILENAME) Import mount coordinates and angles from a plain-text file, 
% as generated by the Pre-Processor tool (V2.0), containing the type, coordinates, orientation,
% and drive-group (e.g. row No. for 1aC articulated trackers) for each mount in a PV-plant.
% The file should contain a series of specifications in the format #spec_id: value, followed 
% by 6 to 9 columns of semicolon-separated-data (depending on the number of rotation-angles 
% required to fully define the mount system):
%
%     #file_format: PREPROCESSOR_VX.X
%     #layout_id: Layout_Name_and_Version
%     #coords_system: CUSTOM
%     #coords_center: 48.7397 N; 9.0971 E; 458
%     #coords_rotation: 0.0
%     #mount_model_idx: 1; mount_model_id_1; 2; mount_model_id_2; ...
%     #(optional comments)
%     #...
%     #n;x;y;z;[tilt;][azimuth;][bank;]group_id;mount_model
%     1;0.000;1.000;0.000;[0.000;][0.000;][0.000;]1;1
%     2;0.000;2.000;0.000;[5.000;][0.000;][0.000;]1;1
%     ...
%    
% Required propperty-value pairs are:
%
%     #file_format: PREPROCESSOR_VX.X,  string used for version control. 
%
%     #layout_id: string ID for the layout, provided by the user.
%
%     #coords_system: In most cases, mount positions will be converted to a custom project-
%       centered Transverse Mercator projection, eliminating angular and scale distortion. 
%
%       WGS84 / EPSG:4326: x,y coordinates read as decimal degrees longitude & latitude. Make sure
%           to provide enough decimals (7-8 for cm/mm precision).
%       UTM XXZ: x,y coordinates in Universal Transverse Mercator projection (zone XXZ, e.g. 30T)
%       CUSTOM: (default) local projection (assumed conformal & equidistant), centered on a given
%           #coords_center and with a given #coords_rotaton from geographical North (see below).
%       See CHECKCOORDSYSTEM and PROJ for other options.
%
%     #coords_center: For CUSTOM coords_system, WGS84 decimal-degree latitude (N) and longitude (E)
%       (at least 6-decimal precision) of project-coordinate-system-origin. For UTM projections, 
%       Common offset (meters) to be added to x,y coordinates before conversion to WGS84.
%
%     #coords_rotation: decimal-degree rotation of project-coordinate-system Y-axis, North->West
%
%     #mount_model_idx: list of mount-model-ID's for existing mount-models in the plant.
%
% Data columns following the '#n;x;y;z;[tilt;azimuth;bank];group_id;mount_model' header represent 
% a single mount per row, with the following fields:
%
%     n: (integer) mount-index, should match the Client’s mount-numbering convention, if existing. 
%     x;y;z:(float) coordinates of the nominal-mount-position, in the local-coordinate-system
%           defined by #coords_center and #coords_rotation, in the header. For tracking systems,
%           the nominal-mount-position must be located over the axis/point of rotation.
%     [tilt;azimuth;bank]: 0 to 3 column decimal-degree rotation-angles (depending on type):
%            2a - no angles required
%           1aV - tilt (angle between mount-plane and a flat-ground)
%       1aF/1aC - tilt (angle between the axis of rotation and a flat-ground)  
%                 azimuth (angle around zenith from NS line to the axis of rotation)
%            0a - tilt (angle around mount's x' axis (usually ~equinox-declination). 
%                 azimuth (angle around zenith from EW line to mount's x' axis)
%                 bank (angle around mount's y' axis to adapt to terrain)  
%           View Pre-processor Specification for further details on angles and coordinate systems.
%     group_id: (integer) indexes that associate each mount to a given group (e.g. a single
%           drive-train, for articulated/linked tracking mechanisms).
%     mount_model: (integer) indexes that associate each mount to a given #mount_model_idx
%           For a single mount-model, all indexes should be 1.
%
% Input:
%   filename - file (path+)name string, or name-pattern (passed to pickfile())
% Output:
%   S.name
%   S.info
%   S.origin - [longitude, latitude, altitude] of coordinates [0,0,0]
%   S.rotation - degrees CCW from North 
%   S.modelidx
%   S.tidx - list of tracker indices
%   S.group
%   S.model
%   S.centers - 3·Ntr array of center point coordinates
%   S.tilt, S.azimuth, S.slope
%
% See also: GUILAYOUT, WRITETRACKERLAYOUT, MOUNTROTATIONS, PLOTTRACKERARRAY, 
%   CHECKCOORDSYSTEM, PROJ 
                                
    DEF_HEADER = {'n','x','y','z','tilt','azimuth','bank','group_id','mount_model'};
    DEF_NAMES = {'tidx','','','','tilt','azimuth','slope','group','model'};

    if nargin < 1, filename = '*'; end
    filename = pickfile(filename,'Pick a plant-layout file');
    
    FLD = {'file_format','layout_id','coords_system','coords_center','coords_rotation',...
        'mount_model_idx','ground_cover_ratio','tilt','azimuth','slope'};
    REQ = {'layout_id','coords_system','coords_center','coords_rotation','mount_model_idx'};
    DEF = { filename  ,'CUSTOM'       ,'0.0;0.0'      ,'0.0'            ,''               };
    
        % SHORT-TIME (hopefully) PROVISIONAL: Pre-Processor issue!!!
        FLD{end+1} = 'wrong_angle_signs';
        DEF{end+1} = false;

    data = readtxtfile(filename,FLD,'delim',';','ignorecase',true,'TreatAsEmpty','/');
    assert(~isempty(data),'Unrecognized file format');
    %data.comments = data.comments(1:end-1); % dump last header line #n;x;y;z;[angles...
    
    info = data.comments;
    params = data.params;
    
    Na = size(data.data,2) - 6; % angle columns
    assert(Na >= 0 && Na <= 3,'importplantlayout:format',...
        'Unrecognized format, don''t know what to do with %d columns',Na + 6);

    errmsg = ' - expecting: n;x;y;z;[tilt;][azimuth;][bank;]group_id;mount_model';
    assert(~isempty(data.headers),['Data doesn''t match header!' errmsg]); 
    [ok,idx] = ismember(lower(data.headers),DEF_HEADER);
    assert(all(ok),[shortliststr(data.headers(~ok),'Invalid header','colon',':') errmsg]); 
    data.headers = DEF_HEADER(idx);
    data.data(idx) = data.data;
    f = false(1,numel(DEF_HEADER)); f(idx) = true;
    [data.data{~f}] = deal({});
    
    [~,idx] = sortrows([data.data{f}],1);
    if ~isequal(idx',1:numel(idx))
        data.data(f) = cellfun(@(x) x(idx),data.data(f),'unif',0);
    end
    data = cell2struct(data.data,DEF_HEADER,2); % structure with fields n,x,y,z,...
    
    S = struct('name',{},'info',{},'origin',{},'rotation',{}); % just for field order
    S(1).name = params.layout_id;

    for j = 1:numel(DEF_HEADER)
        if isempty(DEF_NAMES{j}), continue; end
        if isempty(data.(DEF_HEADER{j})), continue; end
        S.(DEF_NAMES{j}) = data.(DEF_HEADER{j});
    end
    
    % Complete propperty-value pairs with defaults, if missing
    for j = 1:numel(REQ)
        if ~isfield(params,REQ{j})
            params.(REQ{j}) = DEF{j};
            % warning2info('importplantlayout:params','Missing parameter set to default value, %s = %s', REQ{j},DEF{j});
        end
    end

    if isfield(params,'ground_cover_ratio') && ~isempty(params.ground_cover_ratio)
        S.groundcoverratio = str2double(params.ground_cover_ratio); 
    end
    
    for f = {'tilt','azimuth','slope'}
        if isfield(params,f{1})
            if isfield(S,f{1})
                warning('Ignoring redundant field: %s',f{1});
            else
                S.(f{1}) =  str2double(params.(f{1}));
            end
        end
    end
    
    % Parse system-of-coordinate parameters, and make sure x,y are project-centered (rotated) 
    % Transverse-Mercator coordinates.
    [x,y,z,SYS] = checkcoordsystem(data.x,data.y,data.z,params,'-inland','-plot','-recenter','output','prj');
    S.origin = SYS.origin;
    S.rotation = SYS.rotation;
    S.centers = [x,y,z]';

%     % Adjust to 'project' coordinate convention: Equator = -Y
%     dr = rem((SYS.origin(2) < 0)*180 + SYS.rotation,360);
%     if dr ~= 0
%         S.centers(1:2,:) = [cosd(dr),-sind(dr);sind(dr),cosd(dr)]*S.centers(1:2,:);
%         S.rotation = (SYS.origin(2) > 0)*180;
%         if isfield(S,'azimuth'), S.azimuth = S.azimuth + dr; end
%         info{end+1} = sprintf('Note: applying %0.2f° rotation',dr);
%     end

    S.modelidx = reshape(strsplit(params.mount_model_idx,';'),2,[])';
    S.modelidx = LabelMap(str2double(S.modelidx(:,1)),strtrim(S.modelidx(:,2)));

    % fix zero-based indexing
    for f = {'tidx','group','model'}
        if any(S.(f{1}) == 0)
            S.(f{1}) = S.(f{1}) + 1; 
            warning2info('importplantlayout:idx0','Fixing zero-based %s-indexes',f{1});
        end
    end
    
    % fix empty-group & model indices
    if all(isnan(S.group)), S.group(:) = 1; end
    if all(isnan(S.model)), S.model(:) = 1; end    
    if any(S.tidx' ~= 1:numel(S.tidx))
       warning2info('importplantlayout:idx','Mount indices don''t match 1:N, layout might have gaps');
    end
    
    % PROVISIONAL: Pre-Processor issue!!!
    if isfield(params,'wrong_angle_signs')
        badsigns = params.wrong_angle_signs;
        if ischar(badsigns), badsigns = str2num(badsigns) > 0; end %#ok<ST2NM>
        if any(badsigns)
            fields = {'tilt','azimuth','slope'};
            fields(~cellfun(@(f) isfield(S,f),fields)) = [];
            if isscalar(badsigns), badsigns(2:numel(fields)) = badsigns; end
            for f = fields(badsigns), S.(f{1}) = -S.(f{1}); end
        end
    end
    
    S.info = info;
    
    function warning2info(id,msg,varargin)
        info{end+1} = ['warning: ' sprintf(msg,varargin{:})];
        warning(['importpolygonsfile:' id],msg,varargin{:});
    end
end
